<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>jQuery.parseXML demo</title>
  <script src="https://code.jquery.com/jquery-1.10.2.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fast-xml-parser/2.9.2/parser.min.js"></script>
</head>

<body>
  <?xml version="1.0" encoding="UTF-8" ?>
  <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">

    <xs:element name="shiporder">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="orderperson" type="xs:string" />
          <xs:element name="shipto">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="name" type="xs:string" />
                <xs:element name="address" type="xs:string" />
                <xs:element name="city" type="xs:string" />
                <xs:element name="country" type="xs:string" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="item" maxOccurs="unbounded">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="title" type="xs:string" />
                <xs:element name="note" type="xs:string" minOccurs="0" />
                <xs:element name="quantity" type="xs:positiveInteger" />
                <xs:element name="price" type="xs:decimal" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
        <xs:attribute name="orderid" type="xs:string" use="required" />
      </xs:complexType>
    </xs:element>

  </xs:schema>

  <p id="demo"></p>

  <script>
    var xml = `<?xml version="1.0" encoding="UTF-8" ?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">

<xs:element name="shiporder">
  <xs:complexType>
    <xs:sequence>
      <xs:element name="orderperson" type="xs:string"/>
      <xs:element name="shipto">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="name" type="xs:string"/>
            <xs:element name="address" type="xs:string"/>
            <xs:element name="city" type="xs:string"/>
             <xs:element name="country" type="xs:string"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="item" maxOccurs="unbounded">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="title" type="xs:string"/>
            <xs:element name="note" type="xs:string" minOccurs="0"/>
            <xs:element name="quantity" type="xs:positiveInteger"/>
            <xs:element name="price" type="xs:decimal"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="orderid" type="xs:string" use="required"/>
  </xs:complexType>
</xs:element>

</xs:schema>
`;


    var xml2 = `<?xml version="1.0" encoding="UTF-8"?>
<xs:schema targetNamespace="http://tethys.sdsu.edu/schema/1.0" elementFormDefault="unqualified"
    xmlns="http://tethys.sdsu.edu/schema/1.0" xmlns:xs="http://www.w3.org/2001/XMLSchema">
    <xs:include schemaLocation="CommonElements.xsd"/>

    <xs:element name="Event">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="Name" type="xs:string">
                    <xs:annotation>
                        <xs:documentation>Name of event</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="Description">
                    <xs:complexType>
                        <xs:sequence>
                            <xs:element name="Type" type="xs:string">
                                <xs:annotation>
                                    <xs:documentation>Short description of event type, e.g. pile driving</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:element minOccurs="0" name="Info" type="xs:string">
                                <xs:annotation>
                                    <xs:documentation>Textual description of event.</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:group ref="ContactGroup"/>
                        </xs:sequence>
                    </xs:complexType>
                </xs:element>
                <xs:element name="Start" type="xs:dateTime"/>
                <xs:element name="End" type="xs:dateTime"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
</xs:schema>`;

    var xml3 = `<?xml version="1.0" encoding="UTF-8"?>
<xs:schema targetNamespace="http://tethys.sdsu.edu/schema/1.0"
  xmlns="http://tethys.sdsu.edu/schema/1.0" xmlns:xs="http://www.w3.org/2001/XMLSchema"
  elementFormDefault="unqualified">
  <xs:include schemaLocation="CommonElements.xsd"/>
  <xs:element name="Localize">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="Id" type="xs:string">
          <xs:annotation>
            <xs:documentation>Identification string that is unique to all documents of this type</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="Description" type="DescriptionType" minOccurs="0"/>
        <xs:element name="DataSource" type="DataSourceType"/>
        <xs:element name="Algorithm" type="AlgorithmType"/>
        <xs:element name="ResponsibleParty" type="ResponsibleParty">
          <xs:annotation>
            <xs:documentation>Person/organization responsible for generating metadata</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="UserID" type="xs:string">
          <xs:annotation>
            <xs:documentation>User that submitted the document.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="Effort">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="CoordinateSystem">
                <xs:annotation>
                  <xs:documentation>Cartesian or spherical
</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                  <xs:sequence>
                    <xs:element name="Type">
                      <xs:annotation>
                        <xs:documentation>How are positions represented:
WGS84:  global positioning system lat/long
cartesian: m relative to a point
UTM: universal trans Mercatur map-projection</xs:documentation>
                      </xs:annotation>
                      <xs:simpleType>
                        <xs:restriction base="xs:string">
                          <xs:enumeration value="Cartesian"/>
                          <xs:enumeration value="WGS84"/>
                          <xs:enumeration value="UTM"/>
                          <xs:enumeration value="Bearing"/>
                        </xs:restriction>
                      </xs:simpleType>
                    </xs:element>
                    <xs:element name="Relative" type="RelativeLocType" minOccurs="0">
                      <xs:annotation>
                        <xs:documentation>For bearings, this gives the direction vector for the zero bearing.  For cartesian coordinates, this provides the zero point relative to the deployment position.  WHAT DOES THIS MEAN FOR AN ENSEMBLE?</xs:documentation>
                      </xs:annotation>
                    </xs:element>
                    <xs:element name="UTM" type="UTMType" minOccurs="0">
                      <xs:annotation>
                        <xs:documentation>Parameters for Universal Trans Mercatur projections.
NEED TO INVESTIGATE FURTHER AS TO WHETHER THIS OR ANY OTHER PROJECTION IS WORTH ADDING</xs:documentation>
                      </xs:annotation>
                    </xs:element>
                  </xs:sequence>
                </xs:complexType>
              </xs:element>
              <xs:element minOccurs="0" name="ReferencedDocuments">
                <xs:complexType>
                  <xs:sequence maxOccurs="unbounded" minOccurs="1">
                    <xs:element name="Document">
                      <xs:complexType>
                        <xs:sequence>
                          <xs:element name="Type">
                            <xs:annotation>
                              <xs:documentation>What type of document is being referenced?
Detections or Localizations</xs:documentation>
                            </xs:annotation>
                            <xs:simpleType>
                              <xs:restriction base="xs:string">
                                <xs:enumeration value="Detections"/>
                                <xs:enumeration value="Localizations"/>
                              </xs:restriction>
                            </xs:simpleType>
                          </xs:element>
                          <xs:element name="Id" type="xs:string">
                            <xs:annotation>
                              <xs:documentation>Unique identifier string for the document being referenced.</xs:documentation>
                            </xs:annotation>
                          </xs:element>
                          <xs:element name="Index" type="xs:nonNegativeInteger">
                            <xs:annotation>
                              <xs:documentation>All localizations that wish to reference other detections or localizations from the referenced document should use this index value.</xs:documentation>
                            </xs:annotation>
                          </xs:element>
                        </xs:sequence>
                      </xs:complexType>
                    </xs:element>
                  </xs:sequence>
                </xs:complexType>
              </xs:element>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="Localizations">
          <xs:complexType>
            <xs:sequence>
              <xs:element maxOccurs="unbounded" name="Localization" type="LocalizationType"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element minOccurs="0" name="MetadataInfo" type="MetadataInfo">
          <xs:annotation>
            <xs:documentation>Party responsible for this record.  Some applications may make this mandatory.</xs:documentation>
          </xs:annotation>
        </xs:element>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <xs:complexType name="RelativeLocType">
    <xs:choice>
      <xs:element name="Bearing" type="DirectionVectorType"/>
      <xs:element name="Point" type="R3Point"/>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="UTMType">
    <xs:annotation>
      <xs:documentation>Universal Transverse Mercator coordinates
</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Ellipsoid" type="xs:NCName"/>
      <xs:element name="Zone" type="xs:NMTOKEN">
        <xs:annotation>
          <xs:documentation>NS zone [1-60].  Each zone covers 80°S to 84°N in 6° width zones.  Zone 1 180 is 180-186° E with increasing zone #s corresponding to 6° eastward increments.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="x_m" type="xs:decimal"/>
      <xs:element name="y_m" type="xs:decimal"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="AbsoluteLocType">
    <xs:choice> </xs:choice>
  </xs:complexType>
  <xs:complexType name="DirectionVectorType">
    <xs:annotation>
      <xs:documentation>Designed to be a subset of OpenGML DirectionVectorType:  
http://schemas.opengis.net/gml/3.1.1/base/direction.xsd

Unlike the OpenGML, direction may not be specified as a vector, and the verticalAngle is optional.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="horizontalAngle">
        <xs:complexType>
          <xs:simpleContent>
            <xs:extension base="xs:double">
              <xs:attribute fixed="deg" name="uom" use="optional"/>
            </xs:extension>
          </xs:simpleContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="verticalAngle" maxOccurs="1" minOccurs="0">
        <xs:complexType>
          <xs:simpleContent>
            <xs:extension base="xs:double">
              <xs:attribute fixed="deg" name="uom"/>
            </xs:extension>
          </xs:simpleContent>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="DirectionWErrorType">
    <xs:complexContent>
      <xs:extension base="DirectionVectorType">
        <xs:sequence>
          <xs:element name="StdError" type="DirectionVectorType">
            <xs:annotation>
              <xs:documentation>Standard error in degrees for the measurement.</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="R3Point">
    <xs:sequence>
      <xs:element name="x_m" type="xs:decimal"/>
      <xs:element name="y_m" type="xs:decimal"/>
      <xs:element name="z_m" type="xs:decimal" default="0.0" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="R3PointWErrorType">
    <xs:complexContent>
      <xs:extension base="R3Point">
        <xs:sequence>
          <xs:element name="StdError" type="R3Point"/>
          <xs:element minOccurs="0" name="BearingIDs">
            <xs:annotation>
              <xs:documentation>If multiple bearings were used to create this localization, their ids can be provided.</xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element maxOccurs="unbounded" name="EventRef" type="EventType">
                  <xs:annotation>
                    <xs:documentation>Reference to individual bearing within this XML document.</xs:documentation>
                  </xs:annotation>
                </xs:element>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="OrientationType">
    <xs:sequence>
      <xs:element name="Latitude" type="xs:decimal"/>
      <xs:element name="Longitude" type="xs:decimal"/>
      <xs:element name="Depth" type="xs:decimal"/>
      <xs:element name="Timestamp" type="xs:dateTime"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="LocalizationType">
    <xs:sequence>
      <xs:element name="Event" type="xs:string" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Optional tag typically in ISO datetime format YYYY-MM-DDTHH:MM:SSZ identifying this event uniquely within the stream.  For human analysts, it is typical to use the time at which the detection was made.  When present, the combination of the event and attributes that uniquely identify the set of detections (or document name) must be uniqe.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="Time" type="xs:dateTime">
        <xs:annotation>
          <xs:documentation>Time of localization in reference time frame (e.g. time of arrival at primary hydrophone)</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="References" minOccurs="0">
        <xs:annotation>
          <xs:documentation/>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence maxOccurs="1" minOccurs="1">
            <xs:element name="TimeReferenceEnsembleUnit" type="xs:nonNegativeInteger" minOccurs="0">
              <xs:annotation>
                <xs:documentation>STILL NEEDED?
Time references which unit of the ensemble (see TimeReferenceChannel) when ensembles are used.</xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="TimeReferenceChannel" type="xs:nonNegativeInteger" minOccurs="0">
              <xs:annotation>
                <xs:documentation>STILL NEEDED? 
Events are detected at different times on different channels, making it necessary to provide the instrument and channel on which the timestamp references.</xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="Reference">
              <xs:annotation>
                <xs:documentation>Detections/localization used in constructing this localization.
</xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="Index" type="xs:nonNegativeInteger">
                    <xs:annotation>
                      <xs:documentation>Must match instance of Index in ReferencedDocuments.  This permits identification of a specific document.</xs:documentation>
                    </xs:annotation>
                  </xs:element>
                  <xs:element name="EventRef" type="xs:string">
                    <xs:annotation>
                      <xs:documentation>Event identifier that uniquely identifies a detection or localization within a referenced document.</xs:documentation>
                    </xs:annotation>
                  </xs:element>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:choice>
        <xs:element name="Bearing" type="DirectionWErrorType"/>
        <xs:element name="Cartesian">
          <xs:complexType>
            <xs:complexContent>
              <xs:extension base="R3PointWErrorType">
                <xs:group ref="LongLat3"/>
              </xs:extension>
            </xs:complexContent>
          </xs:complexType>
        </xs:element>
        <xs:element name="WGM84">
          <xs:complexType>
            <xs:sequence>
              <xs:group ref="LongLat3"/>
              <xs:element name="StdError" minOccurs="0">
                <xs:complexType>
                  <xs:group ref="LongLat3"/>
                </xs:complexType>
              </xs:element>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:choice>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="ReferencesType">
    <xs:choice> </xs:choice>
  </xs:complexType>
</xs:schema>`;

    var deployment = `<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
  targetNamespace="http://tethys.sdsu.edu/schema/1.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://tethys.sdsu.edu/schema/1.0"
  elementFormDefault="unqualified">
  <!-- 
       Imports that indicate schemaLocation, suitable for deployment
  xmlns:sml="http://www.opengis.net/sensorML/1.0" xmlns:elementFormDefault="qualified" version="1.1"
  <xs:import namespace="http://www.opengis.net/sensorML/1.0"
  schemaLocation="sensorML/1.0.0/sensorML.xsd"/> 
  -->

  <!-- 
       Imports w/o schemaLocation, suitable for development
       (our schema tool slows down when these are included)
  -->
  <!-- <xs:import namespace="http://www.opengis.net/sensorML/1.0"/> -->

  <!-- no longer used -->
  <!-- xmlns:gml="http://www.opengis.net/gml/3.2" -->
  <!--<xs:import namespace="http://www.opengis.net/gml/3.2" 
    schemaLocation="http://schemas.opengis.net/gml/3.2.1/gml.xsd" /> -->


  <!-- Document instance type -->
  <xs:include schemaLocation="CommonElements.xsd"/>
  <xs:element name="Deployment">
    <xs:complexType mixed="true">
      <xs:sequence minOccurs="1" maxOccurs="1">
        <xs:element name="Project" type="xs:string">
          <xs:annotation>
            <xs:documentation>Name of project associated with this deployment.  Can be related to a geographic region, funding source, etc.
</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="DeploymentID" type="xs:int">
          <xs:annotation>
            <xs:documentation>Deployment identifier, a number related to either the Nth deployment operation in a series of deployments or the Nth deployment at a specific site.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element minOccurs="0" name="DeploymentAlias" type="xs:string">
          <xs:annotation>
            <xs:documentation>Alternative deployment description.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:choice>
          <xs:annotation>
            <xs:documentation>Deployment must be associated with a site or a cruise.  </xs:documentation>
          </xs:annotation>
          <xs:sequence>
            <xs:element name="Site" type="xs:string">
              <xs:annotation>
                <xs:documentation>Name for current location.</xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="Cruise" type="xs:string" minOccurs="0">
              <xs:annotation>
                <xs:documentation>Name of deployment cruise.</xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="SiteAliases" minOccurs="0">
              <xs:annotation>
                <xs:documentation>Alternative names for the deployment location</xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence maxOccurs="unbounded">
                  <xs:element name="Site" type="xs:string"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:element name="Cruise" type="xs:string" minOccurs="1">
            <xs:annotation>
              <xs:documentation>Name of deployment cruise.</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:choice>
        <xs:element name="Platform" type="xs:string">
          <xs:annotation>
            <xs:documentation>On what platform is the instrument deployed? (e.g. mooring, tag)</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="Region" minOccurs="0" type="xs:string">
          <xs:annotation>
            <xs:documentation>Name of geographic region.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="Instrument">
          <xs:annotation>
            <xs:documentation>Instrument type and identifier.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence>
              <xs:element name="Type" type="xs:string">
                <xs:annotation>
                  <xs:documentation>Instrument type, e.g. HARP, EAR, Popup, DMON, etc.</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="ID" type="xs:string">
                <xs:annotation>
                  <xs:documentation>Instrument identifier, e.g. serial number</xs:documentation>
                </xs:annotation>
              </xs:element>
            </xs:sequence>
          </xs:complexType>
        </xs:element>

        <xs:element name="SamplingDetails">
          <xs:annotation>
            <xs:documentation>Information about recordings on each channel. Sample rate, quantization bits, etc.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence maxOccurs="unbounded">
              <xs:element name="Channel" type="ChannelInfo"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="QualityAssurance" type="AcousticDataQAType"/>
        <xs:element name="Data">
          <xs:annotation>
            <xs:documentation>Data from instrument, a URI is provided when not present (typical for audio).</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence>
              <xs:element name="Audio">
                <xs:annotation>
                  <xs:documentation>Information about audio data.</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                  <xs:sequence>
                    <xs:element name="URI" type="xs:string">
                      <xs:annotation>
                        <xs:documentation>Uniform Resource Indicator point to audio content.</xs:documentation>
                      </xs:annotation>
                    </xs:element>
                    <xs:element name="Processed" minOccurs="0" type="xs:string">
                      <xs:annotation>
                        <xs:documentation>Pointer to location of data that has been processed (e.g. checked for quality, decimated, etc.)</xs:documentation>
                      </xs:annotation>
                    </xs:element>
                    <xs:element name="Raw" minOccurs="0" type="xs:string">
                      <xs:annotation>
                        <xs:documentation>Pointer to raw data from the instrument.</xs:documentation>
                      </xs:annotation>
                    </xs:element>
                  </xs:sequence>
                </xs:complexType>
              </xs:element>
              <xs:element minOccurs="0" name="Track">
                <xs:annotation>
                  <xs:documentation>A set of measurements about a ship/instrument's track line.</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                  <xs:sequence>
                    <xs:element maxOccurs="unbounded" minOccurs="0" name="Points">
                      <xs:annotation>
                        <xs:documentation>A set of sorted (by time) points associated with one or more tracklines.</xs:documentation>
                      </xs:annotation>
                      <xs:complexType>
                        <xs:sequence>
                          <xs:element minOccurs="0" name="Trackline" type="xs:double">
                            <xs:annotation>
                              <xs:documentation>Optional trackline number.
If unimportant, everything can be put in one Points element.</xs:documentation>
                            </xs:annotation>
                          </xs:element>
                          <xs:element name="Point" maxOccurs="unbounded">
                            <xs:annotation>
                              <xs:documentation>Timestamped measurements:  long/lat, bearing, etc.
Points should be sorted by timestamp.</xs:documentation>
                            </xs:annotation>
                            <xs:complexType>
                              <xs:sequence>
                                <xs:element name="TimeStamp" type="xs:dateTime"/>
                                <xs:group minOccurs="0" ref="LongLat"/>
                                <xs:element minOccurs="0" name="Bearing_DegN">
                                  <xs:annotation>
                                    <xs:documentation>Bearing in degrees [0, 360) relative to true or magnetic north (as specified by north attribute, default magnetic)</xs:documentation>
                                  </xs:annotation>
                                  <xs:complexType>
                                    <xs:simpleContent>
                                      <xs:extension base="BearingDeg">
                                        <xs:attribute default="magnetic" name="north">
                                          <xs:simpleType>
                                            <xs:restriction base="xs:string">
                                              <xs:enumeration value="true"/>
                                              <xs:enumeration value="magnetic"/>
                                            </xs:restriction>
                                          </xs:simpleType>
                                        </xs:attribute>
                                      </xs:extension>
                                    </xs:simpleContent>
                                  </xs:complexType>
                                </xs:element>
                                <xs:element name="Speed_kn" type="xs:double" minOccurs="0">
                                  <xs:annotation>
                                    <xs:documentation>Speed in knots</xs:documentation>
                                  </xs:annotation>
                                </xs:element>
                                <xs:element minOccurs="0" name="Pitch_deg">
                                  <xs:annotation>
                                    <xs:documentation>Instrument pitch [0, 360) degrees</xs:documentation>
                                  </xs:annotation>
                                  <xs:simpleType>
                                    <xs:restriction base="xs:double">
                                      <xs:minInclusive value="0"/>
                                      <xs:maxExclusive value="360"/>
                                    </xs:restriction>
                                  </xs:simpleType>
                                </xs:element>
                                <xs:element minOccurs="0" name="Roll_deg">
                                  <xs:annotation>
                                    <xs:documentation>Instrument roll [0, 360) degrees</xs:documentation>
                                  </xs:annotation>
                                  <xs:simpleType>
                                    <xs:restriction base="xs:double">
                                      <xs:minInclusive value="0"/>
                                      <xs:maxExclusive value="360"/>
                                    </xs:restriction>
                                  </xs:simpleType>
                                </xs:element>
                                <xs:element minOccurs="0" name="Depth_m" type="xs:double">
                                  <xs:annotation>
                                    <xs:documentation>Instrument depth in meters</xs:documentation>
                                  </xs:annotation>
                                </xs:element>
                                <xs:element name="BottomDepth_m" type="xs:double" minOccurs="0">
                                  <xs:annotation>
                                    <xs:documentation>Bottom depth in meters</xs:documentation>
                                  </xs:annotation>
                                </xs:element>
                              </xs:sequence>
                            </xs:complexType>
                          </xs:element>
                        </xs:sequence>
                      </xs:complexType>
                    </xs:element>
                    <xs:element minOccurs="0" name="TrackEffort">
                      <xs:annotation>
                        <xs:documentation>Not all measurements are associated with an instrument/ship's planned trackline (e.g. when in chase mode or transiting between tracklines).  Specify times for track effort here if needed.
</xs:documentation>
                      </xs:annotation>
                      <xs:complexType>
                        <xs:sequence>
                          <xs:sequence>
                            <xs:element minOccurs="1" name="OnPath" type="PathElementType"
                              maxOccurs="unbounded"/>
                            <xs:element maxOccurs="unbounded" minOccurs="0" name="OffPath"
                              type="PathElementType"/>
                          </xs:sequence>
                        </xs:sequence>
                      </xs:complexType>
                    </xs:element>
                    <xs:element name="URI" maxOccurs="unbounded" type="xs:string" minOccurs="0">
                      <xs:annotation>
                        <xs:documentation>Pointer to trackline information.</xs:documentation>
                      </xs:annotation>
                    </xs:element>
                  </xs:sequence>
                </xs:complexType>
              </xs:element>
            </xs:sequence>
          </xs:complexType>
        </xs:element>

        <xs:element name="DeploymentDetails" type="DeploymentRecoveryDetails">
          <xs:annotation>
            <xs:documentation>Instrument deployment location, time, etc.</xs:documentation>
          </xs:annotation>
        </xs:element>

        <xs:element name="RecoveryDetails" type="DeploymentRecoveryDetails" minOccurs="0">
          <xs:annotation>
            <xs:documentation>Instrument recovery, location, time, etc.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="Sensors">
          <xs:annotation>
            <xs:documentation>Sensors on instrument.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence>
              <xs:element name="Audio" maxOccurs="unbounded" type="Audio" minOccurs="0"/>
              <xs:element name="Depth" maxOccurs="unbounded" type="genericSensor" minOccurs="0"/>
              <xs:element name="Sensor" maxOccurs="unbounded" type="unknownSensor" minOccurs="0"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
    </xs:complexType>
    <xs:key name="DeploymentKey">
      <xs:selector xpath="."/>
      <xs:field xpath="Project"/>
      <xs:field xpath="DeploymentID"/>
      <xs:field xpath="Site"/>
      <xs:field xpath="Cruise"/>
    </xs:key>
  </xs:element>


  <!-- Sensor types -->
  <xs:complexType name="genericSensor">
    <xs:sequence minOccurs="1" maxOccurs="1">
      <xs:element name="Number" type="xs:integer"/>
      <xs:element name="SensorID" type="xs:string"/>
      <xs:element name="Geometry" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Geometry relative to platform
	  </xs:documentation>
        </xs:annotation>
        <xs:complexType mixed="true">
          <xs:choice minOccurs="0" maxOccurs="1">
            <xs:element name="x_m" type="xs:double"/>
            <xs:element name="y_m" type="xs:double"/>
            <xs:element name="z_m" type="xs:double"/>
          </xs:choice>
        </xs:complexType>
      </xs:element>
      <xs:element name="Name" type="xs:string" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Optional sensor name</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element minOccurs="0" name="Description" type="xs:string">
        <xs:annotation>
          <xs:documentation>Optional description of sensor</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="unknownSensor">
    <xs:complexContent>
      <xs:extension base="genericSensor">
        <xs:sequence>
          <xs:element name="Type" type="xs:string"/>
          <xs:element name="Properties">
            <xs:complexType>
              <xs:sequence maxOccurs="1">
                <xs:any namespace="##any" processContents="skip" maxOccurs="unbounded" minOccurs="0"
                />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Audio">
    <xs:complexContent>
      <xs:extension base="genericSensor">
        <xs:sequence minOccurs="0">
          <xs:element minOccurs="0" name="HydrophoneID" type="xs:string"/>
          <xs:element minOccurs="0" name="PreampID" type="xs:string"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="ChannelInfo">
    <xs:sequence maxOccurs="unbounded">
      <xs:element name="ChannelNumber" type="xs:nonNegativeInteger">
        <xs:annotation>
          <xs:documentation>Channels and sensors are bound together from Start to End.  While not enforced, we assume channels are numbered from 1 to N.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="SensorNumber" type="xs:int">
        <xs:annotation>
          <xs:documentation>Audio sensor index within the Sensors element.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="Start" type="xs:dateTime"/>
      <xs:element name="End" type="xs:dateTime"/>
      <xs:element name="Sampling">
        <xs:annotation>
          <xs:documentation>Sampling rate and quantization may change over time.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element maxOccurs="unbounded" minOccurs="1" name="Regimen">
              <xs:annotation>
                <xs:documentation>Sampling regimen may change over time.  Each entry shows the start of a sampling configuration.</xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="TimeStamp" type="xs:dateTime"/>
                  <xs:element name="SampleRate_kHz" type="xs:double"/>
                  <xs:element name="SampleBits" type="xs:int"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="Gain" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Initial gain setting (assumed 0 if not populated) and any subsequent changes.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element maxOccurs="unbounded" minOccurs="0" name="Regimen">
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="TimeStamp" type="xs:dateTime"/>
                  <xs:choice>
                    <xs:element name="Gain_dB" type="xs:double"/>
                    <xs:element name="Gain_rel" type="xs:double">
                      <xs:annotation>
                        <xs:documentation>Only used if gain is not calibrated.  Relative gain may be a number on a dial.</xs:documentation>
                      </xs:annotation>
                    </xs:element>
                  </xs:choice>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="DutyCycle" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Duty cycle is represented by the recording duration and the interval from the start of one recording session to the next.  A duration of 3 m and an interval of 5 m would represent a 60% duty cycle, 3 m on, 2 m off.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element maxOccurs="unbounded" minOccurs="0" name="Regimen" nillable="false">
              <xs:annotation>
                <xs:documentation>Duty cycling regimen may change over time.  Each entry shows the start of a duty cycle configuration.  The abscence of entries indicates continuous sampling as would having equal values in RecordingDuration_m and RecordingInterval_m.</xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="TimeStamp" type="xs:dateTime"/>
                  <xs:element name="RecordingDuration_m" type="xs:double"/>
                  <xs:element name="RecordingInterval_m" type="xs:double"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="DeploymentRecoveryDetails">
    <xs:sequence>
      <xs:group ref="LongLat"/>
      <xs:element name="DepthInstrument_m" type="xs:double" minOccurs="0"/>
      <xs:element name="DepthBottom_m" type="xs:double" minOccurs="0"/>
      <xs:element name="TimeStamp" type="xs:dateTime">
        <xs:annotation>
          <xs:documentation>Time at which instrument was deployed/recovered.
Lost instruments: set recovery time to deployment time.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="AudioTimeStamp" type="xs:dateTime">
        <xs:annotation>
          <xs:documentation>Recording start or end - May differ from deployment time.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="Vessel" minOccurs="0" type="xs:string"/>
      <xs:group ref="ContactGroup" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="AcousticDataQAType">
    <xs:complexContent>
      <xs:extension base="QualityAssuranceProcessType">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" name="Quality">
            <xs:annotation>
              <xs:documentation>If no quality assurance, create an entry of Category unverified spanning the acoustic record.</xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:sequence maxOccurs="1">
                <xs:element name="Start" type="xs:dateTime"/>
                <xs:element name="End" type="xs:dateTime"/>
                <xs:element name="Category">
                  <xs:annotation>
                    <xs:documentation>categories: unverified, good, compromised, unusable</xs:documentation>
                  </xs:annotation>
                  <xs:simpleType>
                    <xs:restriction base="xs:string">
                      <xs:enumeration value="unverified"/>
                      <xs:enumeration value="good"/>
                      <xs:enumeration value="compromised"/>
                      <xs:enumeration value="unusable"/>
                    </xs:restriction>
                  </xs:simpleType>
                </xs:element>
                <xs:element minOccurs="0" name="FrequencyRange">
                  <xs:annotation>
                    <xs:documentation>QA metric applies to what frequency range?</xs:documentation>
                  </xs:annotation>
                  <xs:complexType>
                    <xs:sequence>
                      <xs:element name="Low_Hz" type="xs:double"/>
                      <xs:element name="High_Hz" type="xs:double"/>
                    </xs:sequence>
                  </xs:complexType>
                </xs:element>
                <xs:element maxOccurs="unbounded" minOccurs="0" name="Channel" type="xs:integer"/>
                <xs:element minOccurs="0" name="Comment" type="xs:string">
                  <xs:annotation>
                    <xs:documentation>Additional qualitative information</xs:documentation>
                  </xs:annotation>
                </xs:element>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="PathElementType">
    <xs:sequence maxOccurs="1" minOccurs="0">
      <xs:element minOccurs="0" name="Trackline" type="xs:double"/>
      <xs:element name="Start" type="xs:dateTime"/>
      <xs:element name="End" type="xs:dateTime"/>
      <xs:element minOccurs="0" name="Comment" type="xs:string"/>
    </xs:sequence>
  </xs:complexType>
</xs:schema>`;






    function xmlFunc(xml) {
      var parser = new DOMParser();
      var xmlDoc = parser.parseFromString(xml, "text/xml")
      var x = xmlDoc.documentElement.childNodes;
      for (var i = 0; i < x.length; i++) {
        if (x[i].nodeValue == undefined || x[i].nodeValue == null) {
          console.log(x[i].getAttribute("name"));
          console.log(x[i].getAttributeNode("name").nodeValue);
        } else {
          continue;
        }
      }
    }

    //xmlFunc(xml);


    function jquery(xml) {
      var xmlDoc = $.parseXML(xml);
      var name = $(xmlDoc).find('xs:element');
      console.log("name: ", name);
      console.log("all8: ", document.all[8]);
      console.log("all10: ", document.all[10]);
      console.log("all10: ", document.all[10].getAttribute("name"));
    }
    // jquery(xml);






    function working(xml) {
      var xmlDoc = $.parseXML(xml);
      var name = $(xmlDoc).find('xs:element');

      for (var i = 0; i < document.all.length; i++) {

        //      if(document.all[i].getAttribute("name") != null ) {
        //        if(document.all[i-1].getAttribute("name") == null){
        //          console.log("    ");
        //        }
        console.log(document.all[i].getAttribute("name"));
        // }
      }
    }
    //working(xml);
    //console.log(document.all[8]);








    //iterates through the dom depth first method
    function iterateDOMTree(node) {
      console.log("node: ", node);
      // console.log("node.attributes: ", node.attributes);
      // console.log("node.Experiment: ", node.attrib);
      //console.log("--------------");
      //console.log(i + ": ", node.getAttribute("name"));

      for (node = node.firstElementChild; node != null; node = node.nextElementSibling) {
        iterateDOMTree(node);
      }
    }
    var xmlDoc = $.parseXML(deployment);
    // iterateDOMTree(xmlDoc);

    //displaying the XML to see it visually
    console.log(deployment);
    //parsed XML DOM
    console.log(xmlDoc);
    //Print the first layer(BFS method) of xmlDoc
    var firstChildren = $(xmlDoc).children();
    console.log(firstChildren);


    //variable so that the first pass will ignore and not look for a parent
    var firstPass = 0;
    // trying to traverse a three with bredth first method (this will enter each simbling before going into depth)
    function BFSiteration(node) {

      var queue = [];

      queue.push(node);


      currentTree = queue.shift();
      //var i = 0;
      //var length = currentTree.children.length;
      while (currentTree) {

        for (var i = 0; i < currentTree.children.length; i++) {

          var final = currentTree.children[i];
          //  console.log("final: ", final); // console.log("final.nodeName: ", final.nodeName); // console.log("final.hasAttributes(name): ", final.hasAttributes("name")); // console.log("currentTree.nodeType == 1: ", currentTree.nodeType == 1);

          queue.push(final);
          if (currentTree.nodeType == 1 && final.hasAttributes("name") && final.nodeName == "xs:element") { //&& (final.nodeName == "xs:element" || final.nodeName == "xs:complexType)
            firstPass++;
            if (i == 0)
              console.log("---")
            //console.log(final.getAttribute("name"));

            var braking = final.getAttribute("name");
            //////////////////////////////////////////////////
            /////////////////////////////////////////////////
            //cannot find the parent of the first element because it doesnt exist we need to skip the first element
            if (firstPass == 1) {
              console.log("Root:" + " : " + final.getAttribute("name"));
            } else if (final.parentElement.hasAttribute("name")) {
              console.log(final.parentElement.getAttribute("name") + " : " + final.getAttribute("name"));
            } else if (final.parentElement.parentElement.hasAttribute("name")) {
              console.log(final.parentElement.parentElement.getAttribute('name') + " : " + final.getAttribute("name"));
            } else if (final.parentElement.parentElement.parentElement.hasAttribute("name")) {
              console.log(final.parentElement.parentElement.parentElement.getAttribute('name') + " : " + final.getAttribute("name"));
            }
            //////////////////////////////////////////////////
            //////////////////////////////////////////////////
          }
        }
        currentTree = queue.shift();
      }
    }


    console.log("------------");
    BFSiteration(xmlDoc);





    ///while loop contruction area
    //    var currentElement = final; // var root = "false"; // while (final.parentElement.hasAttribute("name") == null) { // //checking if the elemnt is the root element because it does not have a parent // // if (final.parentElement.nodeName == "xs:schema") { // console.log("Root:", final.getAttribute("name")); // root = "true"; // } // final = final.parentElement; // } // if (root == "false") { // console.log(final.getAttribute("name") + " : " + currentElement.getAttribute("name")); // } ///





    ////////////////////////////////////////////////////////////////////////////////////
    //bfs explanation
    //https://code.tutsplus.com/articles/data-structures-with-javascript-tree--cms-23393
    /////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////
    //We can only get the attribute from an array this is an example of it.
    // var element = xmlDoc.getElementsByTagName("xs:element");
    //console.log(element[1].getAttribute("name"));
    /////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////
    //Making JSON object example;
    // console.log("------Making JSON object-----------");
    var obj = new Object();
    obj.cars = {};
    obj.cars.audi = [];
    obj.cars.audi[0] = "A4";
    obj.cars.audi[1] = "A5";
    obj.cars.audi[2] = "A6";
    obj.cars.audi[3] = "A7";

    obj.cars.bmw = [];
    obj.cars.bmw[0] = "B4";
    obj.cars.bmw[1] = "B5";
    obj.cars.bmw[2] = "B6";
    obj.cars.bmw[3] = "B7";

    obj.cars.merc = [];
    obj.cars.merc[0] = "C1";
    obj.cars.merc[1] = "C2";
    obj.cars.merc[2] = "C3";
    obj.cars.merc[3] = "C4";

    // console.log("this is me ", obj.cars.audi);





    var carString = JSON.stringify(obj);
    //console.log(carString);
    ///////////////////////////////////////////////////////////



    /* What to work on next
    
      1. Figure out how to get the parent element inside a while loop.
      2. Constract a json hierarchy with the structure of the parent/child relationship that is being right now printed out in the console
    
    
    
    */

  </script>


</body>

</html>
